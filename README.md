# bcb-week12 线段树，Trie和并查集  
## 线段树  
### 概念  
线段树是一种二叉树，也就是对于一个线段，我们会用一个二叉树来表示。  
但不同的是这棵树的结点储存的值是一个数列中 [ l , r ] [l,r][l,r] 的某个需要的值 （例如，求和，求最大值，求最小值）
这是一棵典型的线段树 ，其性质是 ：
若其中一子节点编号为 a ，则该节点左儿子编号为 2a，其右儿子编号为2a+1
且它的父结点的编号为 a/2 
 （c++语言中除法只取整数部分）。
### 用处  
线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是 O（log2n)  
* 线段树的原理：线段树除了最后一层之外，是一颗满二叉树，假设区间中存在n个数据，则倒数第二层节点数大于为n，从第一层到倒数第三层的节点数大约为n-1，最后一层节点数很少，但是为了使用数组存储整棵树，最后一层大约需要开2n的空间，因此一共需要开辟4n的空间存储线段树。
### 线段树存在五个操作
（1）pushup：由子节点计算父节点的信息；

（2）pushdown：把当前父节点的修改信息下传到子节点，也被称为懒标记（延迟标记）；这个操作比较复杂，一般不涉及到区间修改则不用写。

（3）build：将一段区间初始化成线段树；

（4）modify：修改操作，分为两类：① 单点修改（需要使用pushup），② 区间修改（需要使用pushdown）；

（5）query：查询一段区间的值。  
## Trie  
### 知识简介  
字典树（Trie）可以保存一些<字符串,值>的对应关系。类似于c++的map，但是比map快很多。
Trie 的优点在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关；

Trie 的缺点是空间消耗很高。

Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。
Trie树的基本性质可以归纳为： 
（1）根节点不包含字符，除根节点意外每个节点只包含一个字符。
（2）从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 
（3）每个节点的所有子节点包含的字符串不相同。
（4）如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。
（5）插入查找的复杂度为O(n)，n为字符串长度。

* 基本思想（以字母树为例）：  

1、插入过程  

对于一个单词，从根开始，沿着单词的各个字母所对应的树中的节点分支向下走，直到单词遍历完，将最后的节点标记为红色，表示该单词已插入Trie树。  

2、查询过程  

同样的，从根开始按照单词的字母顺序向下遍历trie树，一旦发现某个节点标记不存在或者单词遍历完成而最后的节点未标记为红色，则表示该单词不存在，若最后的节点标记为红色，表示该单词存在。  
### 字典树的数据结构：  
开始的trie_cnt相当于一个内存池，通过增加trie_cnt的数量来模拟新节点的分配

next数组存放着各个孩子结点的位置（其实就是数组下标）。

如给出字符串"abc","ab","bd","dda"，根据该字符串序列构建一棵Trie树。则构建的树如下:  
![image](https://user-images.githubusercontent.com/73734842/193457420-49ae0330-83f3-488e-82de-1a90d02d9a20.png)
Trie树的根结点不包含任何信息，第一个字符串为"abc"，第一个字母为'a'，因此根结点中数组next下标为'a'-97的值不为NULL，其他同理，构建的Trie树如图所示，红色结点表示在该处可以构成一个单词。很显然，如果要查找单词"abc"是否存在，查找长度则为O(len)，len为要查找的字符串的长度。而若采用一般的逐个匹配查找，则查找长度为O(len*n)，n为字符串的个数。显然基于Trie树的查找效率要高很多。
如上图中：Trie树中存在的就是abc、ab、bd、dda四个单词。在实际的问题中可以将标记颜色的标志位改为数量count等其他符合题目要求的变量。  
### Trie树的操作  
在Trie树中主要有3个操作，插入、查找和删除。但一般情况下用不到删除，所以这里不介绍。
1、插入
假设存在字符串str，Trie树的根结点为root，root一开始为0，i一开始为0。
1)取str[i]，判断trie[root].next[str[i]-97]是否为空。

若为空，则增加trie_node来分配新节点，记新节点的地址为next，把新节点的地址赋给trie[root].next[str[i]-97]，然后root = next；

若不为空，则root=trie[root].next[str[i]-97]；
2)i++，继续取str[i]，重复1)中的操作，直到遇到结束符'\0'，返回当前节点的值。
2、查找
假设要查找的字符串为str，Trie树的根结点为root，root=0，i=root
1)取str[i]，判断判断trie[root].next[str[i]-97]是否为空。

若为空，则返回false；

若不为空，则root=trie[root].next[str[i]-97]，继续取字符。

2)重复1)中的操作直到遇到结束符'\0'，返回当前节点的值。
以下是模板，仅供参考，实际操作还是以题目要求为准：

## 并查集  
###  概论  
* 定义：
并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。

* 主要构成：
并查集主要由一个整型数组pre[ ]和两个函数find( )、join( )构成。
数组 pre[ ] 记录了每个点的前驱节点是谁，函数 find(x) 用于查找指定节点 x 属于哪个集合，函数 join(x,y) 用于合并两个节点 x 和 y 。

* 作用：
并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）
###  find( )函数的定义与实现  
首先我们需要定义一个数组：int pre[1000]; （数组长度依题意而定）。这个数组记录了每个人的上级是谁。这些人从0或1开始编号（依题意而定）。比如说pre[16]=6就表示16号的上级是6号。如果一个人的上级就是他自己，那说明他就是教主了，查找到此结束。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。
每个人都只认自己的上级。比如小昭只知道自己的上级是紫衫龙王。教主是谁？不认识！要想知道自己教主的名称，只能一级级查上去。因此你可以视find(x)这个函数就是找教主用的。
下面给出这个函数的具体实现
  
  int find(int x)					//查找x的教主
{
	while(pre[x] != x)			//如果x的上级不是自己（则说明找到的人不是教主）
		x = pre[x];				//x继续找他的上级，直到找到教主为止
	return x;					//教主驾到~~~
}
### join( )函数的定义与实现  
在上面的情景中，两个已存的不同门派就这样完成了合并。这么重大的变化，要如何实现？要改动多少地方？其实很简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先所有人员的教主就都变成了师太，于是下面的人们也就不会打起来了！反正我们关心的只是连通性，门派内部的结构不要紧的”。玄慈听后立刻就不乐意了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”。抗议无效，我安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个，join()函数的作用就是用来实现这个的。

join(x,y)的执行逻辑如下：
1、寻找 x 的代表元（即教主）；
2、寻找 y 的代表元（即教主）；
3、如果 x 和 y 不相等，则随便选一个人作为另一个人的上级，如此一来就完成了 x 和 y 的合并。
下面给出这个函数的具体实现：
  
  void join(int x,int y)                     //我想让虚竹和周芷若做朋友
{
    int fx=find(x), fy=find(y);            //虚竹的老大是玄慈，芷若MM的老大是灭绝
    if(fx != fy)                           //玄慈和灭绝显然不是同一个人
        pre[fx]=fy;                        //方丈只好委委屈屈地当了师太的手下啦
}
  
  ### 总结  
  1、用集合中的某个元素来代表这个集合，则该元素称为此集合的代表元；
2 、一个集合内的所有元素组织成以代表元为根的树形结构；
3 、对于每一个元素 x，pre[x] 存放 x 在树形结构中的父亲节点（如果 x 是根节点，则令pre[x] = x）；
4 、对于查找操作，假设需要确定 x 所在的的集合，也就是确定集合的代表元。可以沿着pre[x]不断在树形结构中向上移动，直到到达根节点。
因此，基于这样的特性，并查集的主要用途有以下两点：
1、维护无向图的连通性（判断两个点是否在同一连通块内，或增加一条边后是否会产生环）；
2、用在求解最小生成树的Kruskal算法里。


一般来说，一个并查集对应三个操作：
1、初始化（ Init()函数 ）
2、查找函数（ Find()函数 ）
3、合并集合函数（ Join()函数 ）




